/**
 * @file nbody.cu
 * @brief Defines the functions for simulating an N-body gravitational system.
 *
 * This file provides the definition of functions for allocating and initializing an n-body model (NbodyModel), 
 * setting parameters such as mass and scale, and performing various operations on the model 
 * like spinning and speeding up the bodies.
 *
 * Project originally by:
 * David Joiner
 *
 * Modified by:
 * Steven McKelvey - Calvin University, January 2025
 *
 * NOTE: This project's function documentation was generated by ChatGPT on August 22nd, 2024.
 *          Keep in mind that there may be errors and the documentation may not be 100% accurate.
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "nbody.cuh"
#include <X11/Xlib.h>
#include <assert.h>
#include <unistd.h>
#define NIL (0)

/**
 * @brief Allocates memory for an NbodyModel struct based on the value of "num_bodies" 
 *        and allocates space for all its members.
 * 
 * @param num_bodies Number of celestial objects in the simulation.
 * @return A pointer to the newly created NbodyModel struct.
 * 
 * This function initializes the NbodyModel structure, allocating memory for the masses,
 * positions (x, y, z), velocities (vx, vy, vz), and temporary arrays used in the numerical
 * integration (X, X2, XPRIME, XPRIME2, XPRIME3, XPRIME4) of each celestial object.
 */
NbodyModel::NbodyModel(unsigned numBodies)
{
    num_bodies = numBodies;
    mass = new double[numBodies]{0};
    x = new double[numBodies]{0};
    y = new double[numBodies]{0};
    z = new double[numBodies]{0};
    vx = new double[numBodies]{0};
    vy = new double[numBodies]{0};
    vz = new double[numBodies]{0};
    X = new double[numBodies * 6]{0};
    X2 = new double[numBodies * 6]{0};
    XPRIME = new double[numBodies * 6]{0};
    XPRIME2 = new double[numBodies * 6]{0};
    XPRIME3 = new double[numBodies * 6]{0};
    XPRIME4 = new double[numBodies * 6]{0};
}

/**
 * @brief Initializes the NbodyModel with default values.
 *
 * @return An integer indicating success (1) or failure (0).
 * 
 * This function sets the initial positions of the bodies within a defined scale,
 * ensuring they are within a spherical volume. Velocities are initialized to zero,
 * and the gravitational constant is set to its default value.
 */
int NbodyModel::initializeNbodyModel()
{
    double r2;
    double scale = default_scale;
    double r2Max = scale * scale;

    for (unsigned i = 0; i < num_bodies; ++i)
    {
        mass[i] = default_mass;
        do
        {
            x[i] = scale * (2.0 * (double)rand() / (double)RAND_MAX - 1.0);
            y[i] = scale * (2.0 * (double)rand() / (double)RAND_MAX - 1.0);
            z[i] = scale * (2.0 * (double)rand() / (double)RAND_MAX - 1.0);
            r2 = x[i] * x[i] +
                 y[i] * y[i] +
                 z[i] * z[i];
        } while (r2 > r2Max);

        vx[i] = 0.0;
        vy[i] = 0.0;
        vz[i] = 0.0;

        for (unsigned j = 0; j < 6; ++j)
        {
            X[i * 6 + j] = 0.0;
            XPRIME[i * 6 + j] = 0.0;
        }
    }

    G = default_G;
    t = 0.0;
    iteration = 0;

    return 1;
}

/**
 * @brief Frees the memory allocated for the NbodyModel.
 *
 * @return An integer indicating success (1) or failure (0).
 * 
 * This function releases all dynamically allocated memory within the NbodyModel,
 * ensuring there are no memory leaks when the model is no longer needed.
 */
NbodyModel::~NbodyModel()
{
    delete[] x;
    delete[] y;
    delete[] z;
    delete[] vx;
    delete[] vy;
    delete[] vz;
    delete[] X;
    delete[] X2;
    delete[] XPRIME;
    delete[] XPRIME2;
    delete[] XPRIME3;
    delete[] XPRIME4;
}

/**
 * @brief Sets default values for mass, scale, and the gravitational constant in the NbodyModel.
 * 
 * This function assigns default physical constants and scales to the model, which can be adjusted later.
 */
void NbodyModel::setDefaultsNbodyModel()
{
    default_mass = 1.0;    // Default mass (e.g., solar masses)
    default_scale = 10.0;  // Default spatial scale (e.g., parsecs)
    default_G = 0.0046254; // Gravitational constant (pc^3 / Solar_mass / My^2)
}

/**
 * @brief Sets the default mass for all bodies in the NbodyModel.
 *
 * @param mass The mass value to set for all bodies.
 */
void NbodyModel::setMassNbodyModel(double mass)
{
    default_mass = mass;
}

/**
 * @brief Sets the default spatial scale for the NbodyModel.
 *
 * @param scale The spatial scale to set.
 */
void NbodyModel::setScaleNbodyModel(double scale)
{
    default_scale = scale;
}

/**
 * @brief Sets the gravitational constant for the NbodyModel.
 *
 * @param G The gravitational constant to set.
 */
void NbodyModel::setGNbodyModel(double G)
{
    default_G = G;
}

/**
 * @brief Assigns random velocities to all bodies in the N-body system.
 *
 * @param v The magnitude of the velocity to assign.
 * 
 * This function assigns each body a random velocity vector of magnitude `v`, 
 * uniformly distributed in direction.
 */
void NbodyModel::speedNbodyModel(double v)
{
    double pi = atan(1.0) * 4.0;
    double theta, phi;

    for (unsigned i = 0; i < num_bodies; ++i)
    {
        theta = 2 * pi * (double)rand() / (double)RAND_MAX;
        phi = pi * (double)rand() / (double)RAND_MAX;
        vx[i] = v * sin(phi) * cos(theta);
        vy[i] = v * sin(phi) * sin(theta);
        vz[i] = v * cos(phi);
    }
}

/**
 * @brief Applies a rotational spin to the N-body system.
 *
 * @param rotFactor The factor by which to rotate the system.
 * 
 * This function calculates a tangential velocity for each body based on the gravitational influence 
 * of the other bodies within a certain distance. The velocities are adjusted to give the system a rotational spin.
 */
void NbodyModel::spinNbodyModel(double rotFactor)
{
    double ri, rj, sumM, vTan;

    for (unsigned i = 0; i < num_bodies; ++i)
    {
        ri = sqrt(pow(x[i], 2.0) + pow(y[i], 2.0));
        sumM = 0.0;

        for (unsigned j = 0; j < num_bodies; ++j)
        {
            if (i != j)
            {
                rj = sqrt(pow(x[j], 2.0) + pow(y[j], 2.0));
                if (rj < ri)
                {
                    sumM += mass[j];
                }
            }
        }

        if (sumM > 0.0)
        {
            vTan = sqrt(sumM * G / ri);
            vz[i] = 0.0;
            vx[i] = -rotFactor * vTan * y[i] / ri;
            vy[i] = rotFactor * vTan * x[i] / ri;
        }
        else
        {
            vTan = 0.0;
            vz[i] = 0.0;
            vx[i] = 0.0;
            vy[i] = 0.0;
        }
    }
    return;
}

// step methods

/**
 * @brief Advances the state of the N-body model using the selected integration method.
 * 
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int NbodyModel::stepNbodyModel(double tStep)
{
    return stepNbodyModelEuler(tStep);
}

/**
 * @brief Advances the state of the N-body model using the basic Euler method.
 * 
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int NbodyModel::stepNbodyModelEuler(double tStep)
{
    unsigned i;

    // Store the current state (position and velocity) in the X array
    for (i = 0; i < num_bodies; ++i)
    {
        X[i * 6 + 0] = x[i];
        X[i * 6 + 1] = y[i];
        X[i * 6 + 2] = z[i];
        X[i * 6 + 3] = vx[i];
        X[i * 6 + 4] = vy[i];
        X[i * 6 + 5] = vz[i];
    }

    // Calculate derivatives at the current state
    calcDerivs(X, XPRIME, t, tStep);

    // Update the state based on the derivatives
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X[i] += XPRIME[i] * tStep;
    }

    // Update the position and velocity in the model structure
    for (i = 0; i < num_bodies; ++i)
    {
        x[i] = X[i * 6 + 0];
        y[i] = X[i * 6 + 1];
        z[i] = X[i * 6 + 2];
        vx[i] = X[i * 6 + 3];
        vy[i] = X[i * 6 + 4];
        vz[i] = X[i * 6 + 5];
    }

    // Increment the time and iteration counter
    t += tStep;
    iteration++;

    return 1;
}

/**
 * @brief Advances the state of the N-body model using the Improved Euler (Heun's) method.
 * 
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int NbodyModel::stepNbodyModelIEuler(double tStep)
{
    unsigned i;

    // Store the current state (position and velocity) in the X array
    for (i = 0; i < num_bodies; ++i)
    {
        X[i * 6 + 0] = x[i];
        X[i * 6 + 1] = y[i];
        X[i * 6 + 2] = z[i];
        X[i * 6 + 3] = vx[i];
        X[i * 6 + 4] = vy[i];
        X[i * 6 + 5] = vz[i];
    }

    // Calculate derivatives at the current state
    calcDerivs(X, XPRIME, t, tStep);

    // Update the state based on the derivatives
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X2[i] = X[i] + XPRIME[i] * tStep;
    }

    // Recalculate derivatives at the updated state
    calcDerivs(X2, XPRIME2, t, tStep);

    // Average the derivatives
    for (i = 0; i < num_bodies * 6; ++i)
    {
        XPRIME[i] = (XPRIME[i] + XPRIME2[i]) / 2;
    }

    // Final state update
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X[i] = X[i] + XPRIME[i] * tStep;
    }

    // Update the position and velocity in the model structure
    for (i = 0; i < num_bodies; ++i)
    {
        x[i] = X[i * 6 + 0];
        y[i] = X[i * 6 + 1];
        z[i] = X[i * 6 + 2];
        vx[i] = X[i * 6 + 3];
        vy[i] = X[i * 6 + 4];
        vz[i] = X[i * 6 + 5];
    }

    // Increment the time and iteration counter
    t += tStep;
    iteration++;

    return 1;
}

/**
 * @brief Advances the state of the N-body model using the Euler midpoint method.
 * 
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int NbodyModel::stepNbodyModelMPEuler(double tStep)
{
    unsigned i;

    // Store the current state (position and velocity) in the X array
    for (i = 0; i < num_bodies; ++i)
    {
        X[i * 6 + 0] = x[i];
        X[i * 6 + 1] = y[i];
        X[i * 6 + 2] = z[i];
        X[i * 6 + 3] = vx[i];
        X[i * 6 + 4] = vy[i];
        X[i * 6 + 5] = vz[i];
    }

    // Calculate derivatives at the current state
    calcDerivs(X, XPRIME, t, tStep);

    // Update the state based on half of the time step
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X2[i] = X[i] + XPRIME[i] * tStep / 2;
    }

    // Recalculate derivatives at the midpoint
    calcDerivs(X2, XPRIME, t, tStep);

    // Final state update
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X[i] = X[i] + XPRIME[i] * tStep;
    }

    // Update the position and velocity in the model structure
    for (i = 0; i < num_bodies; ++i)
    {
        x[i] = X[i * 6 + 0];
        y[i] = X[i * 6 + 1];
        z[i] = X[i * 6 + 2];
        vx[i] = X[i * 6 + 3];
        vy[i] = X[i * 6 + 4];
        vz[i] = X[i * 6 + 5];
    }

    // Increment the time and iteration counter
    t += tStep;
    iteration++;

    return 1;
}

/**
 * @brief Advances the state of the N-body model using the fourth-order Runge-Kutta method.
 * 
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int NbodyModel::stepNbodyModelRK4(double tStep)
{
    unsigned i;

    // Store the current state (position and velocity) in the X array
    for (i = 0; i < num_bodies; ++i)
    {
        X[i * 6 + 0] = x[i];
        X[i * 6 + 1] = y[i];
        X[i * 6 + 2] = z[i];
        X[i * 6 + 3] = vx[i];
        X[i * 6 + 4] = vy[i];
        X[i * 6 + 5] = vz[i];
    }

    // Calculate derivatives at the current state
    calcDerivs(X, XPRIME, t, tStep);

    // Update the state based on half of the time step
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X2[i] = X[i] + XPRIME[i] * tStep / 2;
    }
    calcDerivs(X2, XPRIME2, t + tStep / 2, tStep);
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X2[i] = X[i] + XPRIME2[i] * tStep / 2;
    }
    calcDerivs(X2, XPRIME3, t + tStep / 2, tStep);
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X2[i] = X[i] + XPRIME3[i] * tStep;
    }
    calcDerivs(X2, XPRIME4, t + tStep, tStep);

    // Combine the derivatives for the final update
    for (i = 0; i < num_bodies * 6; ++i)
    {
        XPRIME[i] += 2.0 * XPRIME2[i] +
                               2.0 * XPRIME3[i] +
                               XPRIME4[i];
        XPRIME[i] /= 6.0;
    }
    for (i = 0; i < num_bodies * 6; ++i)
    {
        X[i] += XPRIME[i] * tStep;
    }

    // Update the position and velocity in the model structure
    for (i = 0; i < num_bodies; ++i)
    {
        x[i] = X[i * 6 + 0];
        y[i] = X[i * 6 + 1];
        z[i] = X[i * 6 + 2];
        vx[i] = X[i * 6 + 3];
        vy[i] = X[i * 6 + 4];
        vz[i] = X[i * 6 + 5];
    }

    // Increment the time and iteration counter
    t += tStep;
    iteration++;

    return 1;
}