/**
 * @file nbody.c
 * @brief Defines the functions for simulating an N-body gravitational system.
 *
 * This file provides the definition of functions for allocating and initializing an n-body model (NbodyModel), 
 * setting parameters such as mass and scale, and performing various operations on the model 
 * like spinning and speeding up the bodies.
 *
 * Project originally by:
 * [Original Author Name]
 *
 * Modified by:
 * Steven McKelvey - Calvin University, August 2024
 *
 * NOTE: This project's function documentation was generated by ChatGPT on August 22nd, 2024.
 *          Keep in mind that there may be errors and the documentation may not be 100% accurate.
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "nbody.h"
#include <mpi.h>
#include <X11/Xlib.h>
#include <assert.h>
#include <unistd.h>
#define NIL (0)

/**
 * @brief Allocates memory for an NbodyModel struct based on the value of "num_bodies" 
 *        and allocates space for all its members.
 * 
 * @param num_bodies Number of celestial objects in the simulation.
 * @return A pointer to the newly created NbodyModel struct.
 * 
 * This function initializes the NbodyModel structure, allocating memory for the masses,
 * positions (x, y, z), velocities (vx, vy, vz), and temporary arrays used in the numerical
 * integration (X, X2, XPRIME, XPRIME2, XPRIME3, XPRIME4) of each celestial object.
 */
NbodyModel *allocateNbodyModel(int num_bodies)
{
    NbodyModel *theModel;
    theModel = (NbodyModel *)malloc(sizeof(NbodyModel));
    theModel->num_bodies = num_bodies;
    theModel->mass = (double *)calloc(num_bodies, sizeof(double));
    theModel->x = (double *)calloc(num_bodies, sizeof(double));
    theModel->y = (double *)calloc(num_bodies, sizeof(double));
    theModel->z = (double *)calloc(num_bodies, sizeof(double));
    theModel->vx = (double *)calloc(num_bodies, sizeof(double));
    theModel->vy = (double *)calloc(num_bodies, sizeof(double));
    theModel->vz = (double *)calloc(num_bodies, sizeof(double));
    theModel->X = (double *)calloc(num_bodies * 6, sizeof(double));
    theModel->X2 = (double *)calloc(num_bodies * 6, sizeof(double));
    theModel->XPRIME = (double *)calloc(num_bodies * 6, sizeof(double));
    theModel->XPRIME2 = (double *)calloc(num_bodies * 6, sizeof(double));
    theModel->XPRIME3 = (double *)calloc(num_bodies * 6, sizeof(double));
    theModel->XPRIME4 = (double *)calloc(num_bodies * 6, sizeof(double));

    return theModel;
}

/**
 * @brief Initializes the NbodyModel with default values.
 *
 * @param theModel Pointer to the NbodyModel to initialize.
 * @return An integer indicating success (1) or failure (0).
 * 
 * This function sets the initial positions of the bodies within a defined scale,
 * ensuring they are within a spherical volume. Velocities are initialized to zero,
 * and the gravitational constant is set to its default value.
 */
int initializeNbodyModel(NbodyModel *theModel)
{
    double r2;
    double scale = theModel->default_scale;
    double r2Max = scale * scale;

    for (int i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->mass[i] = theModel->default_mass;
        do
        {
            theModel->x[i] = scale * (2.0 * (double)rand() / (double)RAND_MAX - 1.0);
            theModel->y[i] = scale * (2.0 * (double)rand() / (double)RAND_MAX - 1.0);
            theModel->z[i] = scale * (2.0 * (double)rand() / (double)RAND_MAX - 1.0);
            r2 = theModel->x[i] * theModel->x[i] +
                 theModel->y[i] * theModel->y[i] +
                 theModel->z[i] * theModel->z[i];
        } while (r2 > r2Max);

        theModel->vx[i] = 0.0;
        theModel->vy[i] = 0.0;
        theModel->vz[i] = 0.0;

        for (int j = 0; j < 6; j++)
        {
            theModel->X[i * 6 + j] = 0.0;
            theModel->XPRIME[i * 6 + j] = 0.0;
        }
    }

    theModel->G = theModel->default_G;
    theModel->t = 0.0;
    theModel->iteration = 0;

    return 1;
}

/**
 * @brief Frees the memory allocated for the NbodyModel.
 *
 * @param theModel Pointer to the NbodyModel to free.
 * @return An integer indicating success (1) or failure (0).
 * 
 * This function releases all dynamically allocated memory within the NbodyModel,
 * ensuring there are no memory leaks when the model is no longer needed.
 */
int freeNbodyModel(NbodyModel *theModel)
{
    free(theModel->x);
    free(theModel->y);
    free(theModel->z);
    free(theModel->vx);
    free(theModel->vy);
    free(theModel->vz);
    free(theModel->X);
    free(theModel->X2);
    free(theModel->XPRIME);
    free(theModel->XPRIME2);
    free(theModel->XPRIME3);
    free(theModel->XPRIME4);
    free(theModel);

    return 1;
}

/**
 * @brief Sets default values for mass, scale, and the gravitational constant in the NbodyModel.
 *
 * @param theModel Pointer to the NbodyModel to configure.
 * 
 * This function assigns default physical constants and scales to the model, which can be adjusted later.
 */
void setDefaultsNbodyModel(NbodyModel *theModel)
{
    theModel->default_mass = 1.0;    // Default mass (e.g., solar masses)
    theModel->default_scale = 10.0;  // Default spatial scale (e.g., parsecs)
    theModel->default_G = 0.0046254; // Gravitational constant (pc^3 / Solar_mass / My^2)
}

/**
 * @brief Sets the default mass for all bodies in the NbodyModel.
 *
 * @param theModel Pointer to the NbodyModel.
 * @param mass The mass value to set for all bodies.
 */
void setMassNbodyModel(NbodyModel *theModel, double mass)
{
    theModel->default_mass = mass;
}

/**
 * @brief Sets the default spatial scale for the NbodyModel.
 *
 * @param theModel Pointer to the NbodyModel.
 * @param scale The spatial scale to set.
 */
void setScaleNbodyModel(NbodyModel *theModel, double scale)
{
    theModel->default_scale = scale;
}

/**
 * @brief Sets the gravitational constant for the NbodyModel.
 *
 * @param theModel Pointer to the NbodyModel.
 * @param G The gravitational constant to set.
 */
void setGNbodyModel(NbodyModel *theModel, double G)
{
    theModel->default_G = G;
}

/**
 * @brief Assigns random velocities to all bodies in the N-body system.
 *
 * @param theModel Pointer to the NbodyModel.
 * @param v The magnitude of the velocity to assign.
 * 
 * This function assigns each body a random velocity vector of magnitude `v`, 
 * uniformly distributed in direction.
 */
void speedNbodyModel(NbodyModel *theModel, double v)
{
    double pi = atan(1.0) * 4.0;
    double theta, phi;

    for (int i = 0; i < theModel->num_bodies; i++)
    {
        theta = 2 * pi * (double)rand() / (double)RAND_MAX;
        phi = pi * (double)rand() / (double)RAND_MAX;
        theModel->vx[i] = v * sin(phi) * cos(theta);
        theModel->vy[i] = v * sin(phi) * sin(theta);
        theModel->vz[i] = v * cos(phi);
    }
}

/**
 * @brief Applies a rotational spin to the N-body system.
 *
 * @param theModel Pointer to the NbodyModel.
 * @param rotFactor The factor by which to rotate the system.
 * 
 * This function calculates a tangential velocity for each body based on the gravitational influence 
 * of the other bodies within a certain distance. The velocities are adjusted to give the system a rotational spin.
 */
void spinNbodyModel(NbodyModel *theModel, double rotFactor)
{
    double ri, rj, sumM, vTan;

    for (int i = 0; i < theModel->num_bodies; i++)
    {
        ri = sqrt(pow(theModel->x[i], 2.0) + pow(theModel->y[i], 2.0));
        sumM = 0.0;

        for (int j = 0; j < theModel->num_bodies; j++)
        {
            if (i != j)
            {
                rj = sqrt(pow(theModel->x[j], 2.0) + pow(theModel->y[j], 2.0));
                if (rj < ri)
                {
                    sumM += theModel->mass[j];
                }
            }
        }

        if (sumM > 0.0)
        {
            vTan = sqrt(sumM * theModel->G / ri);
            theModel->vz[i] = 0.0;
            theModel->vx[i] = -rotFactor * vTan * theModel->y[i] / ri;
            theModel->vy[i] = rotFactor * vTan * theModel->x[i] / ri;
        }
        else
        {
            vTan = 0.0;
            theModel->vz[i] = 0.0;
            theModel->vx[i] = 0.0;
            theModel->vy[i] = 0.0;
        }
    }
    return;
}
