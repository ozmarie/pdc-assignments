/**
 * @file calcDerivs.c
 * @brief Defines the function for calculating the derivatives of the position/velocity 
 *  for all bodies in an N-body system. A function for computing a 
 *  softened gravitational radius is also included in this module.
 *
 * Project originally by:
 * [Original Author Name]
 *
 * Modified by:
 * Steven McKelvey - Calvin University, August 2024
 *
 * NOTE: This project's function documentation was generated by ChatGPT on August 22nd, 2024.
 *          Keep in mind that there may be errors and the documentation may not be 100% accurate.
 */

#include "calcDerivs.h"

/**
 * @brief Calculates the derivatives of the position and velocity for all bodies in the N-body system.
 * 
 * This function computes the time derivatives of the position and velocity (acceleration)
 * of each body in the N-body system. It uses Newton's law of universal gravitation, 
 * applying a softened gravitational radius to avoid singularities during close encounters.
 * 
 * @param x Pointer to an array containing the positions and velocities of all bodies. 
 *          The array is organized in the format [x1, y1, z1, vx1, vy1, vz1, ..., xn, yn, zn, vxn, vyn, vzn].
 * @param derivs Pointer to an array where the computed derivatives will be stored. 
 *               The array has the same structure as `x`.
 * @param t Current simulation time (not used in the calculation).
 * @param tStep Time step for the simulation.
 * @param theModel Pointer to the NbodyModel structure containing the system's physical parameters 
 *                 (e.g., masses, gravitational constant).
 */
void calcDerivs(double *x, double *derivs, double t, double tStep,
                NbodyModel *theModel)
{
    // Loop over each body in the system
    for (int i = 0; i < theModel->num_bodies; i++)
    {
        // Set the derivatives of position to the current velocities
        derivs[i * 6 + 0] = x[i * 6 + 3]; // dx/dt = vx
        derivs[i * 6 + 1] = x[i * 6 + 4]; // dy/dt = vy
        derivs[i * 6 + 2] = x[i * 6 + 5]; // dz/dt = vz
        // Initialize the acceleration components to zero
        derivs[i * 6 + 3] = 0.0;
        derivs[i * 6 + 4] = 0.0;
        derivs[i * 6 + 5] = 0.0;
    }
    for (int i = 0; i < theModel->num_bodies; ++i) {
        // Loop over all other bodies (j > i) to calculate gravitational interactions
        for (int j = i + 1; j < theModel->num_bodies; j++)
        {
            // Compute the softened radius for gravitational force calculation
            double srad = computeSoftenedRadius(theModel->G * theModel->mass[j], tStep);

            // Ensure we don't calculate a body's interaction with itself
            if (i != j)
            {
                // Compute the distance vector components between bodies i and j
                double deltaX = x[j * 6 + 0] - x[i * 6 + 0];
                double deltaY = x[j * 6 + 1] - x[i * 6 + 1];
                double deltaZ = x[j * 6 + 2] - x[i * 6 + 2];
                double rad = sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);

                // Apply gravitational force only if distance is greater than the softened radius
                if (rad > srad)
                {
                    double inv_rad3 = 1.0 / pow(rad, 3.0); // Inverse cubic distance

                    // gravitational constant * inverse rad cubed (1 / rad^3)
                    double grav_effect = theModel->G * inv_rad3;

                    // Update the acceleration components due to body j
                    derivs[i * 6 + 3] += grav_effect * theModel->mass[j];
                    derivs[i * 6 + 4] += grav_effect * theModel->mass[j];
                    derivs[i * 6 + 5] += grav_effect * theModel->mass[j];

                    // Apply Newton's third law to update the acceleration of body j
                    derivs[j * 6 + 3] -= grav_effect * theModel->mass[i];
                    derivs[j * 6 + 4] -= grav_effect * theModel->mass[i];
                    derivs[j * 6 + 5] -= grav_effect * theModel->mass[i];
                }
            }
        }
    }
}

/**
 * @brief Computes a softened gravitational radius for the gravitational force calculation.
 * 
 * This function calculates a softened radius to prevent numerical instabilities that can
 * occur when two bodies are very close to each other. The softened radius is based on 
 * the gravitational constant times the mass and the time step.
 * 
 * @param g_m Product of the gravitational constant (G) and the mass of the interacting body.
 * @param tstep Time step of the simulation.
 * @return double The computed softened radius.
 */
double computeSoftenedRadius(double g_m, double tstep)
{
    // g_m = G * mass;
    return 5.0 * pow(g_m, 0.333) * pow(tstep, 0.667);
}
