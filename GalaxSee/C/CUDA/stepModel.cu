/**
 * @file stepModel.cu
 * @brief Defines the functions for updating the state of the N-body model by one iteration.
 *
 * This file provides the definition of a general function for updating the 
 * state of the model, along with four other functions that provide 
 * different integration methods that the simulation can use.
 *
 * Project originally by:
 * [Original Author Name]
 *
 * Modified by:
 * Steven McKelvey - Calvin University, January 2025
 *
 * NOTE: This project's function documentation was generated by ChatGPT on August 22nd, 2024.
 *          Keep in mind that there may be errors and the documentation may not be 100% accurate.
 */

#include "stepModel.cuh"

/**
 * @brief Advances the state of the N-body model using the selected integration method.
 * 
 * @param theModel A pointer to the NbodyModel structure containing the current state of the system.
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int stepNbodyModel(NbodyModel *theModel, double tStep)
{
    return stepNbodyModelEuler(theModel, tStep);
}

/**
 * @brief Advances the state of the N-body model using the basic Euler method.
 * 
 * @param theModel A pointer to the NbodyModel structure containing the current state of the system.
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int stepNbodyModelEuler(NbodyModel *theModel, double tStep)
{
    int i;

    // Store the current state (position and velocity) in the X array
    for (i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->X[i * 6 + 0] = theModel->x[i];
        theModel->X[i * 6 + 1] = theModel->y[i];
        theModel->X[i * 6 + 2] = theModel->z[i];
        theModel->X[i * 6 + 3] = theModel->vx[i];
        theModel->X[i * 6 + 4] = theModel->vy[i];
        theModel->X[i * 6 + 5] = theModel->vz[i];
    }

    // Calculate derivatives at the current state
    calcDerivs(theModel->X, theModel->XPRIME, theModel->t, tStep, theModel);

    // Update the state based on the derivatives
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X[i] += theModel->XPRIME[i] * tStep;
    }

    // Update the position and velocity in the model structure
    for (i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->x[i] = theModel->X[i * 6 + 0];
        theModel->y[i] = theModel->X[i * 6 + 1];
        theModel->z[i] = theModel->X[i * 6 + 2];
        theModel->vx[i] = theModel->X[i * 6 + 3];
        theModel->vy[i] = theModel->X[i * 6 + 4];
        theModel->vz[i] = theModel->X[i * 6 + 5];
    }

    // Increment the time and iteration counter
    theModel->t += tStep;
    theModel->iteration++;

    return 1;
}

/**
 * @brief Advances the state of the N-body model using the Improved Euler (Heun's) method.
 * 
 * @param theModel A pointer to the NbodyModel structure containing the current state of the system.
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int stepNbodyModelIEuler(NbodyModel *theModel, double tStep)
{
    int i;

    // Store the current state (position and velocity) in the X array
    for (i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->X[i * 6 + 0] = theModel->x[i];
        theModel->X[i * 6 + 1] = theModel->y[i];
        theModel->X[i * 6 + 2] = theModel->z[i];
        theModel->X[i * 6 + 3] = theModel->vx[i];
        theModel->X[i * 6 + 4] = theModel->vy[i];
        theModel->X[i * 6 + 5] = theModel->vz[i];
    }

    // Calculate derivatives at the current state
    calcDerivs(theModel->X, theModel->XPRIME, theModel->t, tStep, theModel);

    // Update the state based on the derivatives
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X2[i] = theModel->X[i] + theModel->XPRIME[i] * tStep;
    }

    // Recalculate derivatives at the updated state
    calcDerivs(theModel->X2, theModel->XPRIME2, theModel->t, tStep, theModel);

    // Average the derivatives
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->XPRIME[i] = (theModel->XPRIME[i] + theModel->XPRIME2[i]) / 2;
    }

    // Final state update
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X[i] = theModel->X[i] + theModel->XPRIME[i] * tStep;
    }

    // Update the position and velocity in the model structure
    for (i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->x[i] = theModel->X[i * 6 + 0];
        theModel->y[i] = theModel->X[i * 6 + 1];
        theModel->z[i] = theModel->X[i * 6 + 2];
        theModel->vx[i] = theModel->X[i * 6 + 3];
        theModel->vy[i] = theModel->X[i * 6 + 4];
        theModel->vz[i] = theModel->X[i * 6 + 5];
    }

    // Increment the time and iteration counter
    theModel->t += tStep;
    theModel->iteration++;

    return 1;
}

/**
 * @brief Advances the state of the N-body model using the Euler midpoint method.
 * 
 * @param theModel A pointer to the NbodyModel structure containing the current state of the system.
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int stepNbodyModelMPEuler(NbodyModel *theModel, double tStep)
{
    int i;

    // Store the current state (position and velocity) in the X array
    for (i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->X[i * 6 + 0] = theModel->x[i];
        theModel->X[i * 6 + 1] = theModel->y[i];
        theModel->X[i * 6 + 2] = theModel->z[i];
        theModel->X[i * 6 + 3] = theModel->vx[i];
        theModel->X[i * 6 + 4] = theModel->vy[i];
        theModel->X[i * 6 + 5] = theModel->vz[i];
    }

    // Calculate derivatives at the current state
    calcDerivs(theModel->X, theModel->XPRIME, theModel->t, tStep, theModel);

    // Update the state based on half of the time step
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X2[i] = theModel->X[i] + theModel->XPRIME[i] * tStep / 2;
    }

    // Recalculate derivatives at the midpoint
    calcDerivs(theModel->X2, theModel->XPRIME, theModel->t, tStep, theModel);

    // Final state update
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X[i] = theModel->X[i] + theModel->XPRIME[i] * tStep;
    }

    // Update the position and velocity in the model structure
    for (i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->x[i] = theModel->X[i * 6 + 0];
        theModel->y[i] = theModel->X[i * 6 + 1];
        theModel->z[i] = theModel->X[i * 6 + 2];
        theModel->vx[i] = theModel->X[i * 6 + 3];
        theModel->vy[i] = theModel->X[i * 6 + 4];
        theModel->vz[i] = theModel->X[i * 6 + 5];
    }

    // Increment the time and iteration counter
    theModel->t += tStep;
    theModel->iteration++;

    return 1;
}

/**
 * @brief Advances the state of the N-body model using the fourth-order Runge-Kutta method.
 * 
 * @param theModel A pointer to the NbodyModel structure containing the current state of the system.
 * @param tStep The time step by which the model state should be advanced.
 * 
 * @return int Returns 1 on success.
 */
int stepNbodyModelRK4(NbodyModel *theModel, double tStep)
{
    int i;

    // Store the current state (position and velocity) in the X array
    for (i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->X[i * 6 + 0] = theModel->x[i];
        theModel->X[i * 6 + 1] = theModel->y[i];
        theModel->X[i * 6 + 2] = theModel->z[i];
        theModel->X[i * 6 + 3] = theModel->vx[i];
        theModel->X[i * 6 + 4] = theModel->vy[i];
        theModel->X[i * 6 + 5] = theModel->vz[i];
    }

    // Calculate derivatives at the current state
    calcDerivs(theModel->X, theModel->XPRIME, theModel->t, tStep, theModel);

    // Update the state based on half of the time step
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X2[i] = theModel->X[i] + theModel->XPRIME[i] * tStep / 2;
    }
    calcDerivs(theModel->X2, theModel->XPRIME2, theModel->t + tStep / 2, tStep, theModel);
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X2[i] = theModel->X[i] + theModel->XPRIME2[i] * tStep / 2;
    }
    calcDerivs(theModel->X2, theModel->XPRIME3, theModel->t + tStep / 2, tStep, theModel);
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X2[i] = theModel->X[i] + theModel->XPRIME3[i] * tStep;
    }
    calcDerivs(theModel->X2, theModel->XPRIME4, theModel->t + tStep, tStep, theModel);

    // Combine the derivatives for the final update
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->XPRIME[i] += 2.0 * theModel->XPRIME2[i] +
                               2.0 * theModel->XPRIME3[i] +
                               theModel->XPRIME4[i];
        theModel->XPRIME[i] /= 6.0;
    }
    for (i = 0; i < theModel->num_bodies * 6; ++i)
    {
        theModel->X[i] += theModel->XPRIME[i] * tStep;
    }

    // Update the position and velocity in the model structure
    for (i = 0; i < theModel->num_bodies; ++i)
    {
        theModel->x[i] = theModel->X[i * 6 + 0];
        theModel->y[i] = theModel->X[i * 6 + 1];
        theModel->z[i] = theModel->X[i * 6 + 2];
        theModel->vx[i] = theModel->X[i * 6 + 3];
        theModel->vy[i] = theModel->X[i * 6 + 4];
        theModel->vz[i] = theModel->X[i * 6 + 5];
    }

    // Increment the time and iteration counter
    theModel->t += tStep;
    theModel->iteration++;

    return 1;
}
